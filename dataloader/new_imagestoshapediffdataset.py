# -*- coding: utf-8 -*-
"""new_ImagesToShapeDiffDataset.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zrGM0wrPQ5C03eMdQ39KNZ68tAV6-3oo
"""

#!pip install dlib
#!pip install opencv-python
#!pip install --upgrade imutils

import dlib
import cv2

import numpy as np
import pandas as pd

import imutils
import os

from PIL import Image

from matplotlib import pyplot as plt
from dlib_fd import dlib_landmark_detector



class shapeDifTwinsDataloader(Dataset):
    def __init__(self, dataroot, df_img, df_relations, transform, path_to_predictors):
        '''
        dataroot: path to folder with items
        df: pandas dataframe matadata(hasn't been changed)
        df_relatinos: pandas dataframe with relations between classes
        transform: torchvision flip and notflip transforms for  images(dict)
        '''
        self.dataroot = dataroot
        self.df = df[df[' yaw']==0]
        self.transform = transform
        self.relations=df_relations
        self.list_notexist=[]
        
        self.dfd = dlib_landmark_detector(cnn_flag='True', 
                             bb_detector_path = os.path.join(path_to_predictors, 'mmod_human_face_detector.dat'), 
                             landmark_predictor_path = os.path.join(path_to_predictors,'shape_predictor_68_face_landmarks.dat'))
    
    
    def get_flipped_features(self, img):
        img_8bit = np.array(img)
        img_8bit = np.pad(img_8bit, ((0,50),(40,40),(0,0)), mode='median')
        self.dfd.reset()
        self.dfd.face_detect(img_8bit, visualize=False)

        face_cropped = dlib.get_face_chip(self.dfd._rescaled_image.copy(), self.dfd.landmark_shape, size=256, padding=0.15)
        #face_cropped = np.flip(face_cropped, axis=1) # to flip
        
        self.dfd.reset()
        self.dfd.face_detect(face_cropped, visualize=False)
        return self.dfd.get_original_size_landmarks()
    
    def distance(self, shape1, shape2): 
        return np.sqrt( np.power(shape1 - shape2, 2).sum(axis=1))
    
    
    def __getitem__(self, index):
        
        def get_img_path(img_id):
            return self.dataroot+f'{img_id[:5]}/{img_id[:-4]}__face.jpg'
        
        monetochka=np.random.randint(0,2)
        #print(monetochka)
        id_a = self.df['filename'].iloc[index]
        img_a = Image.open(get_img_path(id_a))
        
        if monetochka==0: 
            find_id=self.relations['subject_id1'].str.find(id_a[:5])
            #print(find_id[find_id!=-1].index.tolist())
            if find_id[find_id!=-1].index.tolist():               
                id_b=self.relations['subject_id2'].iloc[find_id[find_id!=-1].index].values
                relation=self.relations['relationship_type'].iloc[find_id[find_id!=-1].index].values


                if relation[0] in ['Fraternal','Identical','IdenticalMirror','IdenticalTriplet']:
                    flag='Twins'
                    find_id=self.df['filename'].str.find(str(id_b[0][4:]))
                    id_b=self.df['filename'].loc[find_id[find_id!=-1].index[np.random.randint(0,len(find_id[find_id!=-1].index))]]
                    img_b = Image.open(get_img_path(id_b))
                    img_b=self.transform['notflip'](img_b)
                else:
                    id_b=id_a
                    img_b=img_a.copy()
                    img_b=self.transform['notflip'](img_b)
                    flag='Not Twins'
            else:
                id_b=id_a
                img_b=img_a.copy()
                img_b=self.transform['notflip'](img_b)
                flag='Not Twins'
        else:
            id_b=id_a
            img_b=img_a.copy()
            img_b=self.transform['notflip'](img_b)
            flag='Not Twins'
    
        img_a = self.transform['notflip'](img_a)

        id_a=id_a[:5]
        id_b=id_b[:5]
        
        # Get shape and differences
        shape_a = get_flipped_features(img_a)
        shape_b = get_flipped_features(img_b)
        distance = self.distance(shape_a, shape_b)
        
        return {'distance': distance, 'class_a':id_a,'class_b':id_b,'label':flag}

    def __len__(self):
        return self.df.shape[0]